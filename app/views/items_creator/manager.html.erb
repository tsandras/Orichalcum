<%= content_tag :div, class: 'components-block' do -%>
  <%= form_tag items_creator_save_components_path, method: :post do |f| %>
    <%= select_tag 'template[id]', options_for_select(@templates.map{|t| [t.name, t.id]}) %>
  <% end %>
<% end -%>
<%= render 'template_form' %>

<div id="phaser-example">
</div>

<script type="text/javascript">
  function Template(game, templateData, x, y) {
    this.x = x;
    this.y = y;
    this.game = game;
    if (templateData) {
      this.id = templateData.id;
      this.name = templateData.name;
      this.data = templateData;
      this.text = game.add.text(
        this.x + 55, this.y + 10, '', { font: '12px', fill: '#000',
        align: 'left', boundsAlignH: 'left', boundsAlignV: 'top',
        wordWrap: true, wordWrapWidth: 300 }
      );
      this.text.setTextBounds(0, 0, 80, 30);
      this.text.visible = false;
      this.text.text = this.name +": " + templateData.description
    }
    this.getCenter = function() {
      return {x: this.x + 25, y: this.y + 25};
    };
    this.load = function() {
      this.game.load.image(this.name, this.data.image_thumb_url);
    }
  }

  function TemplatesTree(game, tree, xroot, yroot) {
    var self = this;
    self.game = game;
    self.xroot = xroot;
    self.yroot = yroot;
    self.allSprites = {};
    self.allGraphics = [];
    self.disconnected = {};
    var getPositionOfFirst = function(nbsComponents, x) {
      var half = Math.round(nbsComponents / 2);
      return x - (half + 1) * 100;
    }
    self.setTree = function(tree) {
      self.tree = constructTree(tree, self.xroot, self.yroot);
    }
    self.removeTree = function() {
      if (self.tree) {
        self.allGraphics.forEach(function(graphic) {
          graphic.clear();
        });
        self.allGraphics = [];
        subRemoveTree(self.tree);
        self.tree = null;
      }
    }
    var subRemoveTree = function subRemoveTree(tree) {
      if (self.allSprites[tree.template.name]) {
        var sprite = self.allSprites[tree.template.name];
        sprite.kill();
        self.allSprites[tree.template.name] = null;
      }
      tree.template.text.destroy();
      tree.components.forEach(function(component) {
        subRemoveTree(component, name);
      });
    }
    var constructTree = function(tree, x, y) {
      var noeud = { 
        template: new Template(self.game, tree.template, x, y),
        components: [] 
      }
      var nbsComponents = tree.components.length
      var xtemp = getPositionOfFirst(nbsComponents, x)
      var i = 1;
      tree.components.forEach(function(component) {
        if (nbsComponents % 2 == 0 && i == 2) {
          xtemp = xtemp + 200;
        } else {
          xtemp = xtemp + 100;
        }
        i++;
        noeud.components.push(constructTree(component, xtemp, y + 100))
      });
      return noeud;
    }
    if (tree) {
      self.tree = constructTree(tree, self.xroot, self.yroot);
    } else {
      self.tree = null;
    }
    var connectTwoTemplates = function(t1, t2) {
      var graphics = self.game.add.graphics(0, 0);
      graphics.beginFill(0xFF3300);
      graphics.lineStyle(3, 0xA9A9A9, 1);
      graphics.moveTo(t1.getCenter().x, t1.getCenter().y);
      graphics.lineTo(t2.getCenter().x, t2.getCenter().y);
      graphics.endFill();
      self.allGraphics.push(graphics);
    }
    var subDrawConnection = function subDrawConnection(tree) {
      tree.components.forEach(function(component) {
        subDrawConnection(component);
        connectTwoTemplates(tree.template, component.template)
      });
    }
    self.drawConnection = function() {
      subDrawConnection(self.tree);
    }
    var subGetTemplate = function subGetTemplate(tree, name) {
      if (tree.template.name == name) {
        out = tree.template;
        return;
      }
      tree.components.forEach(function(component) {
        subGetTemplate(component, name);
      });
    }
    self.getTemplate = function(name) {
      // TODO improve getTemplate...
      out = null;
      subGetTemplate(self.tree, name);
      return out;
    }
    var subLoad = function subLoad(tree) {
      tree.template.load();
      tree.components.forEach(function(component) {
        subLoad(component);
      });
    }
    self.load = function load() {
      subLoad(self.tree);
    }
    self.removeNode = function(node, x, y) {
      subRemoveNode(this.tree, node, x, y);
    }
    var subRemoveNode = function subRemoveNode(tree, node, x, y) {
      if (tree.template == node) {
        tree.template = new Template(self.game, null, node.x, node.y);
        tree.template.name = node.x + ";" + node.y;
        var defaultt = game.add.sprite(node.x, node.y, 'default');
        self.allSprites[node.x + ";" + node.y] = defaultt;
        node.text.x = x + 55;
        node.text.y = y + 10;
        self.disconnected[node.name] = node;
      }
      tree.components.forEach(function(component) {
        subRemoveNode(component, node, x, y);
      });
    }
    self.changeNode = function(node, x, y) {
      subChangeNode(this.tree, node, x, y);
    }
    var subChangeNode = function subChangeNode(tree, node, x, y) {
      if (x < tree.template.x + 50 && x > tree.template.x - 50 &&
      y < tree.template.y + 50 && y > tree.template.y - 50 && 
      node.name != tree.template.name) {
        self.disconnected[tree.template.name] = tree.template;
        self.allSprites[tree.template.name].kill();
        var tmpX = tree.template.x;
        var tmpY = tree.template.y;
        tree.template = node;
        tree.template.x = tmpX;
        tree.template.y = tmpY;
        tree.template.text.x = tmpX + 55;
        tree.template.text.y = tmpY + 10;
      }
      tree.components.forEach(function(component) {
        subChangeNode(component, node, x, y);
      });
    }
    self.isNearTo = function(x, y) {
      out = false;
      subIsNearTo(this.tree, x, y);
      return out;
    }
    var subIsNearTo = function subIsNearTo(tree, x, y) {
      if (x < tree.template.x + 50 && x > tree.template.x - 50 &&
      y < tree.template.y + 50 && y > tree.template.y - 50) {
        out = true;
        return;
      }
      tree.components.forEach(function(component) {
        subIsNearTo(component, x, y);
      });
    }
  }

  $('#template_id').change(function() {
    var template = $("#template_id option:selected");
    $.ajax({
      type: 'POST',
      url: '/items_creator/templates_tree',
      data: {id: template.val()},
      success: function(response, textStatus) {
        templatesTree.removeTree();
        templatesTree.setTree(response);
        templatesTree.load();
        templatesTree.drawConnection();
        game.load.start();
      }
    });
  });


  var game = new Phaser.Game(800, 600, Phaser.AUTO, 'phaser-example', { preload: preload, create: create });
  var templatesTree = new TemplatesTree(game, null, 250, 50);

  var text;
  var counter = 0;

  function preload() {
    game.load.image('default', '/templates/empty_location.png');
  }

  function create() {
    game.stage.backgroundColor = "#FFFFFF";
    game.load.onFileComplete.add(fileComplete, this);
  }

  function loadStart() {
    text.setText("Loading ...");
  }

  function fileComplete(progress, cacheKey, success, totalLoaded, totalFiles) {
    var template = templatesTree.getTemplate(cacheKey);
    var newSprite = game.add.sprite(template.x, template.y, cacheKey);
    newSprite.inputEnabled = true;
    newSprite.input.enableDrag();
    newSprite.events.onInputOver.add(over, {template: template}, this);
    newSprite.events.onInputOut.add(listener, {template: template}, this);
    newSprite.events.onDragStop.add(onDragStop, {template: template}, this);
    templatesTree.allSprites[cacheKey] = newSprite;
  }

  function over(item) {
    item.input.useHandCursor = true;
    this.template.text.visible = true;
  }

  function listener(item) {
    this.template.text.visible = false;
  }

  function onDragStop(sprite, pointer) {
    var t = templatesTree.getTemplate(sprite.key);
    if (!t) {
      t = templatesTree.disconnected[sprite.key];
    }
    if (templatesTree.isNearTo(pointer.x, pointer.y)) {
      templatesTree.changeNode(t, pointer.x, pointer.y);
    } else {
      templatesTree.removeNode(t, pointer.x, pointer.y);
    }
  }

  function loadComplete() {
    text.setText("Load Complete");
  }
</script>
