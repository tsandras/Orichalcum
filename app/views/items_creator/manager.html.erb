<%= content_tag :div, class: 'components-block' do -%>
  <%= form_tag items_creator_save_components_path, method: :post do |f| %>
    <%= select_tag 'template[id]', options_for_select(@templates.map{|t| [t.name, t.id]}) %>
  <% end %>
<% end -%>
<%= render 'template_form' %>

<div id="phaser-example">
</div>

<script type="text/javascript">

  function Template(game, templateData, x, y) {
    this.x = x;
    this.y = y;
    this.game = game;
    this.id = templateData.id;
    this.name = templateData.name;
    this.data = templateData;
    this.text = game.add.text(
      this.x + 55, this.y + 10, '', { font: '12px', fill: '#000',
      align: 'left', boundsAlignH: 'left', boundsAlignV: 'top',
      wordWrap: true, wordWrapWidth: 300 }
    );
    this.text.setTextBounds(0, 0, 80, 30);
    this.text.visible = false;
    this.text.text = this.name +": " + templateData.description
    this.getCenter = function() {
      return {x: this.x + 25, y: this.y + 25};
    };
    this.draw = function() {
      game.add.sprite(this.x, this.y, this.name);
    }
    this.load = function() {
      this.game.load.image(this.name, this.data.image_thumb_url);
    }
  }

  function TemplatesTree(game, tree, xroot, yroot) {
    var self = this;
    self.game = game;
    self.xroot = xroot;
    self.yroot = yroot;
    self.allSprites = {};
    self.allGraphics = [];
    var getPositionOfFirst = function(nbsComponents, x) {
      var half = Math.round(nbsComponents / 2);
      return x - (half + 1) * 100;
    }
    self.setTree = function(tree) {
      self.tree = constructTree(tree, self.xroot, self.yroot);
    }
    self.removeTree = function() {
      if (self.tree) {
        self.allGraphics.forEach(function(graphic) {
          graphic.clear();
        });
        self.allGraphics = [];
        subRemoveTree(self.tree);
        self.tree = null;
      }
    }
    var subRemoveTree = function subRemoveTree(tree) {
      if (self.allSprites[tree.template.name]) {
        var sprite = self.allSprites[tree.template.name];
        sprite.kill();
        self.allSprites[tree.template.name] = null;
      }
      tree.template.text.destroy();
      tree.components.forEach(function(component) {
        subRemoveTree(component, name);
      });
    }
    var constructTree = function(tree, x, y) {
      var noeud = { 
        template: new Template(self.game, tree.template, x, y),
        components: [] 
      }
      var nbsComponents = tree.components.length
      var xtemp = getPositionOfFirst(nbsComponents, x)
      var i = 1;
      tree.components.forEach(function(component) {
        if (nbsComponents % 2 == 0 && i == 2) {
          xtemp = xtemp + 200;
        } else {
          xtemp = xtemp + 100;
        }
        i++;
        noeud.components.push(constructTree(component, xtemp, y + 100))
      });
      return noeud;
    }
    if (tree) {
      self.tree = constructTree(tree, self.xroot, self.yroot);
    } else {
      self.tree = null;
    }
    var connectTwoTemplates = function(t1, t2) {
      var graphics = self.game.add.graphics(0, 0);
      graphics.beginFill(0xFF3300);
      graphics.lineStyle(3, 0xffd900, 1);
      graphics.moveTo(t1.getCenter().x, t1.getCenter().y);
      graphics.lineTo(t2.getCenter().x, t2.getCenter().y);
      graphics.endFill();
      self.allGraphics.push(graphics);
    }
    var subDrawConnection = function subDrawConnection(tree) {
      tree.components.forEach(function(component) {
        subDrawConnection(component);
        connectTwoTemplates(tree.template, component.template)
      });
    }
    self.drawConnection = function() {
      subDrawConnection(self.tree);
    }
    var subGetTemplate = function subGetTemplate(tree, name) {
      if (tree.template.name == name) {
        out = tree.template;
        return;
      }
      tree.components.forEach(function(component) {
        subGetTemplate(component, name);
      });
    }
    self.getTemplate = function(name) {
      // TODO improve getTemplate...
      out = null;
      subGetTemplate(self.tree, name);
      return out;
    }
    var subLoad = function subLoad(tree) {
      tree.template.load();
      tree.components.forEach(function(component) {
        subLoad(component);
      });
    }
    self.load = function load() {
      subLoad(self.tree);
    }
  }

  $('#template_id').change(function() {
    var template = $("#template_id option:selected");
    $.ajax({
      type: 'POST',
      url: '/items_creator/templates_tree',
      data: {id: template.val()},
      success: function(response, textStatus) {
        templatesTree.removeTree();
        templatesTree.setTree(response);
        templatesTree.load();
        game.load.start();
        templatesTree.drawConnection();
      }
    });
  });


  var game = new Phaser.Game(800, 600, Phaser.AUTO, 'phaser-example', { preload: preload, create: create });
  var templatesTree = new TemplatesTree(game, null, 250, 50);

  var text;
  var counter = 0;

  function preload() {

  }

  function create() {
    game.stage.backgroundColor = "#FFFFFF";

    game.load.onFileComplete.add(fileComplete, this);
  }

  function loadStart() {
    text.setText("Loading ...");
  }

  //  This callback is sent the following parameters:
  function fileComplete(progress, cacheKey, success, totalLoaded, totalFiles) {
    // text.setText("File Complete: " + progress + "% - " + totalLoaded + " out of " + totalFiles);
    var template = templatesTree.getTemplate(cacheKey);
    var newSprite = game.add.sprite(template.x, template.y, cacheKey);
    newSprite.events.onInputDown.add(function() {
      if (template.text.visible) {
        template.text.visible = false;
      } else {
        template.text.visible = true;
      }
    }, this);
    newSprite.inputEnabled = true;
    // text = game.add.text(250, 12, '', { fill: '#000' });
    templatesTree.allSprites[cacheKey] = newSprite;
    // newImage.scale.set(0.3);
  }

  function loadComplete() {
    text.setText("Load Complete");
  }

  // function listener () {
  //   console.log('toto');
  //   template.text.visible = true;
  // }
</script>
